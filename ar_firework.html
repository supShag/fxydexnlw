<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR æ„¿æœ›çƒŸèŠ±æ£’ (æè‡´è¾‰å…‰ç‰ˆ)</title>

    <!-- MediaPipe AI åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js 3D å¼•æ“åŠè¾‰å…‰åå¤„ç† -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <style>
        :root {
            --glass-bg: rgba(15, 15, 20, 0.7);
            --glass-border: rgba(255, 255, 255, 0.15);
            --accent-color: #ffaa00;
            --accent-glow: rgba(255, 170, 0, 0.8);
            --text-main: #ffffff;
        }

        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", Roboto, sans-serif;
            color: var(--text-main); user-select: none; -webkit-user-select: none;
            touch-action: none; 
        }
        
        #webgl-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #input_video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        /* --- é®ç½©ä¸ UI --- */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s; backdrop-filter: blur(10px);
        }
        
        .tutorial-box {
            background: rgba(20, 20, 30, 0.8); border: 1px solid var(--accent-color);
            padding: 25px 30px; border-radius: 20px; text-align: left; margin-bottom: 30px;
            box-shadow: 0 0 30px rgba(255, 170, 0, 0.2); max-width: 85%; line-height: 1.6;
        }
        .tutorial-box h2 { margin: 0 0 15px 0; color: var(--accent-color); text-align: center; }
        .tutorial-box li { margin-bottom: 10px; color: #ddd; font-size: 0.95rem; }
        .highlight { color: #fff; font-weight: bold; background: rgba(255,170,0,0.3); padding: 2px 6px; border-radius: 4px; }

        #start-btn, .action-btn {
            padding: 16px 40px; font-size: 1.2rem; background: var(--accent-color); color: #fff;
            border: none; border-radius: 50px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 25px var(--accent-glow); transition: 0.3s;
        }
        #start-btn:hover, .action-btn:hover { transform: scale(1.05); }

        .top-bar {
            position: absolute; top: 20px; left: 24px; right: 24px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 60; pointer-events: none;
        }

        .btn-icon {
            background: var(--glass-bg); border: 1px solid var(--glass-border);
            color: white; padding: 10px 16px; border-radius: 12px; cursor: pointer; 
            backdrop-filter: blur(12px); font-size: 0.95rem; display: flex; align-items: center; 
            gap: 8px; pointer-events: auto; transition: 0.3s;
        }

        #game-ui {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; z-index: 50; pointer-events: none;
        }
        .progress-box {
            background: var(--glass-bg); border: 1px solid var(--glass-border);
            padding: 8px 24px; border-radius: 20px; font-weight: bold; letter-spacing: 1px;
            backdrop-filter: blur(10px); display: flex; align-items: center; gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #crystal-count { color: var(--accent-color); font-size: 1.2rem; text-shadow: 0 0 10px var(--accent-glow); }
        #action-hint { font-size: 0.9rem; color: #eee; margin-top: 10px; font-weight: 500; text-align: center; background: rgba(0,0,0,0.5); padding: 6px 16px; border-radius: 20px; text-shadow: 0 1px 2px rgba(0,0,0,0.8); }

        #tips { position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10; font-size: 0.95rem; color: rgba(255,255,255,0.9); pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }

        #victory-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8);
            background: rgba(20,20,30,0.95); border: 2px solid var(--accent-color);
            padding: 40px; border-radius: 20px; text-align: center; z-index: 100;
            display: none; opacity: 0; transition: 0.5s; backdrop-filter: blur(15px);
            box-shadow: 0 0 50px rgba(255, 170, 0, 0.4);
        }
        #victory-modal h1 { margin: 0 0 10px 0; color: var(--accent-color); text-shadow: 0 0 20px var(--accent-glow); }
        #victory-modal p { margin-bottom: 30px; color: #eee; font-size: 1.1rem; }
    </style>
</head>
<body>

    <div id="start-overlay">
        <div class="tutorial-box">
            <h2>âœ¨ å¯»æ˜ŸæŒ‡å— âœ¨</h2>
            <ul>
                <li>ğŸ–±ï¸ <b>ç§»åŠ¨</b>ï¼šä½ çš„æ‰‹æŒ‡/é¼ æ ‡æ˜¯ä¸€æ ¹<span class="highlight">ç‡ƒçƒ§çš„çƒŸèŠ±æ£’</span>ã€‚</li>
                <li>ğŸ¯ <b>ç‚¹äº®</b>ï¼šç›´æ¥ç”¨ç«èŠ±<span class="highlight">è§¦ç¢°</span>æ„¿æœ›æ˜Ÿå³å¯ã€‚</li>
                <li>ğŸ”„ <b>æ—‹è½¬</b>ï¼šæŒ‰ä½æ‹–æ‹½ / åŒæŒ‡æ»‘åŠ¨ï¼Œæ—‹è½¬æ˜Ÿç©ºå¯»æ‰¾æ›´å¤šæ„¿æœ›ã€‚</li>
                <li>âœ¨ <b>æœºåˆ¶</b>ï¼šç¬¬ä¸€æ¬¡è§¦ç¢°æµ®ç°æ°”æ³¡ï¼Œç¬¬äºŒæ¬¡è§¦ç¢°æ”¶é›†æ„¿æœ›ã€‚</li>
            </ul>
        </div>
        <button id="start-btn" onclick="startApp()">å¼€å¯æ„¿æœ›ä¹‹æ—…</button>
        <div id="loading-text" style="display:none; margin-top: 15px; color:#aaa;">æ­£åœ¨åŠ è½½é­”æ³•å¼•æ“...</div>
    </div>

    <div id="victory-modal">
        <h1>âœ¨ æ„¿æœ›å…¨éƒ¨æ”¶é›† âœ¨</h1>
        <p>ç¥ä½ ä»Šå¤œå¥½æ¢¦ï¼Œæ‰€æœ‰çš„ç¾å¥½éƒ½ä¼šå¦‚çº¦è€Œè‡³ã€‚</p>
        <button class="action-btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
    </div>

    <div class="top-bar">
        <div class="btn-icon danger" onclick="exitToRPG()"><span>ğŸšª ç¦»å¼€æ˜Ÿç©º</span></div>
    </div>

    <div id="game-ui">
        <div class="progress-box">
            ğŸŒŸ æ”¶é›†æ„¿æœ›: <span id="crystal-count">0 / 8</span>
        </div>
        <div id="action-hint">ç§»åŠ¨çƒŸèŠ±æ£’å»è§¦ç¢°æ˜Ÿæ˜Ÿ</div>
    </div>

    <div id="tips">
        <p><b>å¼ å¼€æ‰‹/æŒ‰ä½æ‹–æ‹½</b> æ—‹è½¬è§†è§’ Â· <b>å•æŒ‡/é¼ æ ‡ç§»åŠ¨</b> è§¦ç¢°æ„¿æœ›æ˜Ÿ</p>
    </div>

    <div id="webgl-container"></div>
    <video id="input_video" playsinline webkit-playsinline muted></video>

<script>
    const DAILY_WISHES = [
        "ä»Šæ™šä¸ç†¬å¤œ", "åƒé¡¿ç«é”…ä¸é•¿èƒ–", "å‘¨æœ«å¥½å¤©æ°”", "å‡†æ—¶ä¸‹ç­", 
        "é’±åŒ…é¼“é¼“", "çŒ«å’ªè´´è´´", "æŠ¢åˆ°æ¼”å”±ä¼šé—¨ç¥¨", "ç¡åˆ°è‡ªç„¶é†’", 
        "é‡åˆ°æ‡‚æˆ‘çš„äºº", "è€ƒè¯•å…¨è¿‡", "çƒ¦æ¼é€€æ•£", "ä»Šå¤©è¢«å¤¸å¥–", 
        "å–å¥¶èŒ¶ä¸å¤±çœ ", "å¥½è¿åŠ æ»¡", "è¯´èµ°å°±èµ°çš„æ—…è¡Œ", "å¹³å®‰å–œä¹", "ä¸‡äº‹èƒœæ„"
    ];

    // ==========================================
    // 1. å…¨å±€å˜é‡
    // ==========================================
    const videoElement = document.getElementById('input_video');
    const container = document.getElementById('webgl-container');
    const crystalCountEl = document.getElementById('crystal-count');
    const actionHintEl = document.getElementById('action-hint');
    const victoryModal = document.getElementById('victory-modal');
    
    let handsAI; 
    let gameState = {
        totalWishes: 8,
        collectedCount: 0,
        isGameOver: false,
        cameraAngle: 0
    };

    let scene, camera, renderer, composer, raycaster;
    let clock = new THREE.Clock();
    
    let wishes = []; 
    let hitboxes = []; 
    let magicWandSystem, fireworkSystem;
    let textSprites = []; 
    
    const cursor = { x: null, y: null, active: false };
    const pointerState = { isDragging: false, lastX: 0 };

    // ==========================================
    // 2. Three.js åˆå§‹åŒ–
    // ==========================================
    function initThreeJS() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 1.0;

        const ambientLight = new THREE.AmbientLight(0x222244);
        scene.add(ambientLight);

        // --- Bloom é˜ˆå€¼æ§åˆ¶ ---
        const renderScene = new THREE.RenderPass(scene, camera);
        // é˜ˆå€¼ 0.9ï¼Œåªæœ‰æäº®ç‰©ä½“å‘å…‰
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.9);
        bloomPass.threshold = 0.9; 
        bloomPass.strength = 1.6; // ç¨å¾®å¢åŠ å¼ºåº¦ï¼Œé…åˆæ˜Ÿæ˜Ÿçš„ HDR é¢œè‰²
        bloomPass.radius = 0.6;

        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        createStarfield();

        // ç²’å­ç³»ç»Ÿ
        magicWandSystem = new MagicWandParticleSystem(scene);
        fireworkSystem = new FireworkSystem(scene);

        spawnWishes();
        setupInputHandlers();

        window.addEventListener('resize', onWindowResize, false);
    }

    function createStarfield() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        for (let i = 0; i < 1500; i++) {
            vertices.push((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        const material = new THREE.PointsMaterial({ color: 0x88ccff, size: 0.15, transparent: true, opacity: 0.5 });
        scene.add(new THREE.Points(geometry, material));
    }

    // ==========================================
    // 3. æ¸¸æˆé€»è¾‘
    // ==========================================
    function spawnWishes() {
        wishes.forEach(w => { scene.remove(w.mesh); scene.remove(w.hitbox); });
        textSprites.forEach(t => scene.remove(t));
        wishes = []; hitboxes = []; textSprites = [];
        
        const geo = new THREE.IcosahedronGeometry(0.8, 2); // ç»†åˆ†å¤šä¸€ç‚¹ï¼Œæ›´åœ†æ¶¦
        const hitboxGeo = new THREE.SphereGeometry(2.0, 8, 8); 

        for(let i=0; i<gameState.totalWishes; i++) {
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e, 
                emissive: 0x050510, 
                roughness: 0.7,
                metalness: 0.1
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            const hitboxMat = new THREE.MeshBasicMaterial({ visible: false }); 
            const hitbox = new THREE.Mesh(hitboxGeo, hitboxMat);

            const angle = (i / gameState.totalWishes) * Math.PI * 2;
            const radius = 8;
            const x = Math.cos(angle) * radius;
            const y = (Math.random() - 0.5) * 6;
            const z = Math.sin(angle) * radius;
            
            mesh.position.set(x, y, z);
            hitbox.position.set(x, y, z); 
            
            // åˆå§‹çŠ¶æ€ä¸‹å…‰æ™•è¾ƒæš—ä¸”å°
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0x3355bb, 
                transparent: true, 
                opacity: 0.1, 
                wireframe: true 
            });
            const glowMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1.0, 1), glowMat);
            mesh.add(glowMesh);

            scene.add(mesh);
            scene.add(hitbox);
            
            const wishData = { 
                mesh: mesh, hitbox: hitbox, glow: glowMesh, textSprite: null,
                state: 0, lastTouchTime: 0, 
                rotSpeedX: Math.random()*0.02, rotSpeedY: Math.random()*0.02 
            };
            wishes.push(wishData);
            hitboxes.push(hitbox); 
            hitbox.userData = { wish: wishData };
        }
        updateUI();
    }

    function createTextSprite(message) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 1024; 
        canvas.height = 512;
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2 - 40;

        const rectWidth = 800;
        const rectHeight = 220;
        const rectX = centerX - rectWidth / 2;
        const rectY = centerY - rectHeight / 2;
        const cornerRadius = 60;

        function drawBubblePath(ctx) {
            ctx.beginPath();
            ctx.moveTo(rectX + cornerRadius, rectY);
            ctx.lineTo(rectX + rectWidth - cornerRadius, rectY);
            ctx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + cornerRadius);
            ctx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerRadius);
            ctx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - cornerRadius, rectY + rectHeight);
            ctx.lineTo(centerX + 30, rectY + rectHeight);
            ctx.lineTo(centerX, rectY + rectHeight + 60);
            ctx.lineTo(centerX - 30, rectY + rectHeight);
            ctx.lineTo(rectX + cornerRadius, rectY + rectHeight);
            ctx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - cornerRadius);
            ctx.lineTo(rectX, rectY + cornerRadius);
            ctx.quadraticCurveTo(rectX, rectY, rectX + cornerRadius, rectY);
            ctx.closePath();
        }

        context.shadowBlur = 0; 
        drawBubblePath(context);
        context.fillStyle = "rgba(240, 240, 240, 0.95)"; 
        context.fill();

        context.save();
        context.shadowColor = "rgba(255, 100, 0, 1.0)"; 
        context.shadowBlur = 50; 
        
        drawBubblePath(context);
        context.lineWidth = 15;
        context.strokeStyle = "#ffaa00"; 
        context.stroke();
        context.restore();

        context.font = "bold 85px 'Segoe UI', 'Microsoft YaHei', sans-serif";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillStyle = "#333333"; 
        context.shadowBlur = 0; 
        context.fillText(message, centerX, centerY);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture, 
            transparent: true, 
            depthTest: false,
            opacity: 1.0 
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(10, 5, 1); 
        return sprite;
    }

    function updateInteraction() {
        if(gameState.isGameOver || cursor.x === null) return;

        raycaster.setFromCamera({ x: cursor.x, y: cursor.y }, camera);

        const wandPos = new THREE.Vector3();
        raycaster.ray.at(10, wandPos); 
        magicWandSystem.emit(wandPos);

        const intersects = raycaster.intersectObjects(hitboxes);
        
        if (intersects.length > 0) {
            const hit = intersects[0];
            const wish = hit.object.userData.wish;
            
            if (wish && wish.state < 2) {
                magicWandSystem.emit(hit.point); 

                const now = Date.now();
                if (now - wish.lastTouchTime > 1200) { 
                    if (wish.state === 0) {
                        lightUpWish(wish);
                        wish.lastTouchTime = now;
                        actionHintEl.innerText = "æ„¿æœ›å·²æµ®ç°ï¼å†æ¬¡è§¦ç¢°å°†å…¶æ”¶é›†";
                        actionHintEl.style.color = "#ffd700";
                    } else if (wish.state === 1) {
                        collectWish(wish);
                        wish.lastTouchTime = now;
                        actionHintEl.innerText = "æ”¶é›†æˆåŠŸï¼å¯»æ‰¾ä¸‹ä¸€ä¸ª";
                        actionHintEl.style.color = "#fff";
                    }
                }
            }
        }
    }

    // --- æ ¸å¿ƒä¼˜åŒ–ï¼šæ˜Ÿæ˜Ÿç‚¹äº®é€»è¾‘ (HDR è¾‰å…‰) ---
    function lightUpWish(w) {
        w.state = 1;
        
        // 1. è®¾ç½®æé«˜çš„è‡ªå‘å…‰ RGB å€¼ (å¤§äº 1.0) æ¥ç©¿é€ Bloom
        // è¿™æ ·å³ä½¿èƒŒæ™¯å¾ˆé»‘ï¼Œæ˜Ÿæ˜Ÿä¹Ÿä¼šçˆ†å‘å‡ºå¼ºçƒˆçš„é‡‘å…‰
        w.mesh.material.color.setHex(0xffaa00);
        w.mesh.material.emissive.setRGB(3.5, 1.8, 0.5); // HDR è¶…äº®
        w.mesh.material.roughness = 0.2; // å˜å…‰æ»‘
        w.mesh.material.metalness = 0.6; // é‡‘å±è´¨æ„Ÿ
        
        // 2. å…‰æ™•å±‚åŠ å¼º
        w.glow.material.color.setHex(0xffdd44);
        w.glow.material.opacity = 0.5; // ä¸é€æ˜åº¦æå‡
        // åˆå§‹æ”¾å¤§
        w.glow.scale.set(1.4, 1.4, 1.4);

        // 3. æ°”æ³¡ç”Ÿæˆ
        const randomWish = DAILY_WISHES[Math.floor(Math.random() * DAILY_WISHES.length)];
        const sprite = createTextSprite(randomWish);
        sprite.position.copy(w.mesh.position);
        sprite.position.y += 2.2; 
        scene.add(sprite);
        
        sprite.scale.set(0, 0, 1);
        sprite.userData = { life: 1.0, floatSpeed: 0.1, targetScale: new THREE.Vector3(10, 5, 1) };
        
        w.textSprite = sprite;
        textSprites.push(sprite);
        fireworkSystem.explode(w.mesh.position, 50, [3.0, 2.5, 1.0]); 
    }

    function collectWish(w) {
        w.state = 2;
        fireworkSystem.explode(w.mesh.position, 150);
        scene.remove(w.mesh); scene.remove(w.hitbox); 
        if (w.textSprite) {
            scene.remove(w.textSprite);
            textSprites = textSprites.filter(t => t !== w.textSprite);
        }
        gameState.collectedCount++;
        updateUI();
        if(gameState.collectedCount >= gameState.totalWishes) setTimeout(triggerVictory, 1000);
    }

    function updateUI() {
        crystalCountEl.innerText = `${gameState.collectedCount} / ${gameState.totalWishes}`;
    }

    function setupInputHandlers() {
        const dom = renderer.domElement;
        const updateCursor = (cx, cy) => {
            cursor.x = (cx / window.innerWidth) * 2 - 1;
            cursor.y = -(cy / window.innerHeight) * 2 + 1;
            cursor.active = true;
        };
        dom.addEventListener('pointerdown', (e) => { pointerState.isDragging = true; pointerState.lastX = e.clientX; updateCursor(e.clientX, e.clientY); });
        dom.addEventListener('pointermove', (e) => { updateCursor(e.clientX, e.clientY); if (pointerState.isDragging) { const deltaX = e.clientX - pointerState.lastX; gameState.cameraAngle -= deltaX * 0.005; pointerState.lastX = e.clientX; } });
        dom.addEventListener('pointerup', () => { pointerState.isDragging = false; });
        dom.addEventListener('pointerleave', () => { pointerState.isDragging = false; cursor.active = false; });
    }

    function onResults(results) {
        if (results.multiHandLandmarks) {
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const landmarks = results.multiHandLandmarks[i];
                const tipsY = [landmarks[8].y, landmarks[12].y, landmarks[16].y, landmarks[20].y];
                const pipsY = [landmarks[6].y, landmarks[10].y, landmarks[14].y, landmarks[18].y];
                const isPalmOpen = tipsY[0]<pipsY[0] && tipsY[1]<pipsY[1] && tipsY[2]<pipsY[2] && tipsY[3]<pipsY[3];
                const p9 = landmarks[9], p0 = landmarks[0];
                const ndcX = - ((p9.x * 0.75 + p0.x * 0.25) * 2 - 1); 
                const ndcY = - ((p9.y * 0.75 + p0.y * 0.25) * 2 - 1);

                if (isPalmOpen) {
                    if (ndcX > 0.4) gameState.cameraAngle += 0.03;
                    if (ndcX < -0.4) gameState.cameraAngle -= 0.03;
                } else {
                    cursor.x = ndcX; cursor.y = ndcY; cursor.active = true;
                }
            }
        }
    }

    class MagicWandParticleSystem {
        constructor(scene) {
            this.poolSize = 400; this.particles = [];
            this.geometry = new THREE.BufferGeometry();
            this.positions = new Float32Array(this.poolSize * 3);
            this.colors = new Float32Array(this.poolSize * 3);
            for(let i=0; i<this.poolSize; i++) this.particles.push({ active: false, life: 0, pos: new THREE.Vector3(), vel: new THREE.Vector3() });
            this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
            this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
            this.points = new THREE.Points(this.geometry, new THREE.PointsMaterial({ size: 0.4, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false }));
            scene.add(this.points);
        }
        emit(origin) {
            for(let i=0; i<4; i++) {
                const p = this.particles.find(p => !p.active);
                if(p) { p.active = true; p.life = 1.0; p.pos.copy(origin); p.vel.set((Math.random()-0.5)*3, (Math.random()-0.5)*3 + 1, (Math.random()-0.5)*3); }
            }
        }
        update(dt) {
            const posAttr = this.geometry.attributes.position; const colAttr = this.geometry.attributes.color;
            for(let i=0; i<this.poolSize; i++) {
                const p = this.particles[i];
                if(p.active) {
                    p.pos.addScaledVector(p.vel, dt); p.vel.y -= 3.0*dt; p.life -= dt*2.0;
                    if(p.life <= 0) { p.active = false; posAttr.setXYZ(i, 0, 0, 1000); }
                    else { 
                        posAttr.setXYZ(i, p.pos.x, p.pos.y, p.pos.z); 
                        // ç²’å­ä¾ç„¶ä¿æŒé«˜äº®
                        colAttr.setXYZ(i, 5.0*p.life, 3.0*p.life, 0.5*p.life); 
                    }
                }
            }
            posAttr.needsUpdate = true; colAttr.needsUpdate = true;
        }
    }

    class FireworkSystem {
        constructor(scene) {
            this.poolSize = 1000; this.particles = [];
            this.geometry = new THREE.BufferGeometry();
            this.positions = new Float32Array(this.poolSize * 3);
            this.colors = new Float32Array(this.poolSize * 3);
            for(let i=0; i<this.poolSize; i++) this.particles.push({ active: false, life: 0, pos: new THREE.Vector3(), vel: new THREE.Vector3(), color: new THREE.Color() });
            this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
            this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
            this.points = new THREE.Points(this.geometry, new THREE.PointsMaterial({ size: 0.3, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false }));
            scene.add(this.points);
            this.palettes = [[2.5,0.8,0.4], [0.4,2.0,2.5], [2.5,0.5,2.0], [2.5,2.5,1.0]];
        }
        explode(origin, count=120, forceColor=null) {
            const palette = forceColor || this.palettes[Math.floor(Math.random()*this.palettes.length)];
            let spawned = 0;
            for(let i=0; i<this.poolSize && spawned<count; i++) {
                const p = this.particles[i];
                if(!p.active) {
                    p.active = true; p.life = 1.0 + Math.random()*0.6; p.pos.copy(origin);
                    const theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
                    const speed = Math.random()*8+4;
                    p.vel.set(speed*Math.sin(phi)*Math.cos(theta), speed*Math.sin(phi)*Math.sin(theta), speed*Math.cos(phi));
                    p.color.setRGB(palette[0] * 2.0, palette[1] * 2.0, palette[2] * 2.0); 
                    spawned++;
                }
            }
        }
        update(dt) {
            const posAttr = this.geometry.attributes.position; const colAttr = this.geometry.attributes.color;
            for(let i=0; i<this.poolSize; i++) {
                const p = this.particles[i];
                if(p.active) {
                    p.pos.addScaledVector(p.vel, dt); p.vel.multiplyScalar(0.92); p.vel.y -= 2.5*dt; p.life -= dt*0.7;
                    if(p.life <= 0) { p.active = false; posAttr.setXYZ(i, 0, 0, 1000); }
                    else { posAttr.setXYZ(i, p.pos.x, p.pos.y, p.pos.z); colAttr.setXYZ(i, p.color.r*p.life, p.color.g*p.life, p.color.b*p.life); }
                }
            }
            posAttr.needsUpdate = true; colAttr.needsUpdate = true;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        const now = Date.now();

        if (!pointerState.isDragging && !cursor.active) gameState.cameraAngle += dt * 0.05; 
        camera.position.x = Math.sin(gameState.cameraAngle) * 15;
        camera.position.z = Math.cos(gameState.cameraAngle) * 15;
        camera.lookAt(0, 0, 0); 

        updateInteraction();

        wishes.forEach(w => {
            if (w.state < 2) {
                w.mesh.rotation.x += w.rotSpeedX; w.mesh.rotation.y += w.rotSpeedY;
                if(w.state === 1) { 
                    // å‘¼å¸æ•ˆæœï¼šåŠ¨æ€æ”¹å˜ HDR Emissive å¼ºåº¦
                    const pulse = 2.0 + Math.sin(now * 0.005) * 1.5; // åœ¨ 0.5 ~ 3.5 ä¹‹é—´æ³¢åŠ¨
                    w.mesh.material.emissiveIntensity = pulse;
                    
                    w.glow.rotation.x -= w.rotSpeedX * 2; 
                    w.mesh.position.y += Math.sin(now * 0.005 + w.mesh.position.x) * 0.01; 
                    
                    // å…‰æ™•å¤§å°åŒæ­¥å‘¼å¸
                    w.glow.scale.setScalar(1.4 + Math.sin(now * 0.005) * 0.1);
                }
            }
        });
        
        textSprites.forEach(s => { 
            s.position.y += s.userData.floatSpeed * dt; 
            s.lookAt(camera.position); 
            if (s.scale.x < s.userData.targetScale.x) {
                s.scale.lerp(s.userData.targetScale, 0.1);
            }
            s.material.opacity = 1.0; 
        });

        magicWandSystem.update(dt);
        fireworkSystem.update(dt);
        composer.render();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    async function startApp() {
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('loading-text').style.display = 'block';
        try {
            initThreeJS();
            handsAI = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            handsAI.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            handsAI.onResults(onResults);
            
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: "user" } });
            videoElement.srcObject = stream;
            await new Promise(r => videoElement.onloadedmetadata = r);
            await videoElement.play();
            
            document.getElementById('start-overlay').style.opacity = '0';
            setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
            animate();
            processVideoLoop();
        } catch (e) {
            document.getElementById('loading-text').innerText = "å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™";
        }
    }

    async function processVideoLoop() {
        if (!videoElement.paused && !videoElement.ended) await handsAI.send({image: videoElement});
        requestAnimationFrame(processVideoLoop);
    }

    function restartGame() {
        gameState.collectedCount = 0; gameState.isGameOver = false;
        victoryModal.style.opacity = '0';
        setTimeout(() => victoryModal.style.display = 'none', 500);
        actionHintEl.innerText = "ç§»åŠ¨çƒŸèŠ±æ£’å»è§¦ç¢°æ˜Ÿæ˜Ÿ"; actionHintEl.style.color = "#ddd";
        spawnWishes();
    }
    
    function exitToRPG() { window.parent.postMessage("CLOSE_AR_WINDOW", "*"); }
</script>
</body>
</html>
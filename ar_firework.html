<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR é­”æ³•ä»™å¥³æ£’ (RPG Maker ä¸“ç”¨ç‰ˆ)</title>

    <script>
        // æ¬ºéª— MediaPipeï¼Œè®©å®ƒä»¥ä¸ºæ˜¯åœ¨æ™®é€šæµè§ˆå™¨è€Œé Node.js ç¯å¢ƒä¸­
        window._oldModule = window.module;
        window.module = undefined; 
        window.exports = undefined;
        window.__dirname = ''; 
    </script>

    <script src="mediapipe/camera_utils.js"></script>
    <script src="mediapipe/control_utils.js"></script>
    <script src="mediapipe/drawing_utils.js"></script>
    <script src="mediapipe/hands.js"></script>

    <style>
        /* --- ä»å‰¯æœ¬æ–‡ä»¶ä¸­æå–çš„å®Œæ•´æ ·å¼ --- */
        :root {
            --glass-bg: rgba(20, 20, 28, 0.75);
            --glass-border: rgba(255, 255, 255, 0.12);
            --glass-highlight: rgba(255, 255, 255, 0.05);
            --accent-color: #ffd700;
            --accent-glow: rgba(255, 215, 0, 0.4);
            --text-main: #ffffff;
            --text-sub: rgba(255, 255, 255, 0.7);
        }

        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            color: var(--text-main);
            user-select: none; -webkit-user-select: none;
        }
        canvas { position: absolute; top: 0; left: 0; }
        #input_video { display: none; }

        /* æŒ‰é’®æ ·å¼ */
        .btn-icon {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: white; padding: 10px 16px; border-radius: 12px;
            cursor: pointer; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            font-size: 0.95rem; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            pointer-events: auto;
        }
        .btn-icon:hover { 
            background: rgba(255, 255, 255, 0.1); 
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        .btn-icon.danger { border-color: rgba(255, 100, 100, 0.3); }
        .btn-icon.danger:hover { background: rgba(255, 50, 50, 0.2); }

        /* é¡¶éƒ¨æ  */
        .top-bar {
            position: absolute; top: 20px; left: 24px; right: 24px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 60; pointer-events: none;
        }

        /* è®¾ç½®é¢æ¿ */
        #settings-panel {
            position: absolute; top: 70px; left: 24px; z-index: 60;
            background: rgba(18, 18, 24, 0.9); 
            border: 1px solid var(--glass-border);
            padding: 20px; border-radius: 16px; 
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            width: 260px; display: none; flex-direction: column; gap: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            transform-origin: top left; animation: panelFadeIn 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-height: 80vh; overflow-y: auto; pointer-events: auto;
        }
        @keyframes panelFadeIn { from { opacity: 0; transform: scale(0.9) translateY(-10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        
        .panel-section { display: flex; flex-direction: column; gap: 10px; }
        .panel-title { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: rgba(255,255,255,0.5); font-weight: 600; margin-bottom: 2px; }
        
        .control-row { display: flex; justify-content: space-between; align-items: center; }
        .control-label { font-size: 0.9rem; color: #eee; }
        
        select, input[type="range"] {
            background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1);
            color: white; padding: 6px; border-radius: 8px; outline: none; width: 100%; box-sizing: border-box;
            transition: 0.2s;
        }
        select:hover { background: rgba(255,255,255,0.12); }
        input[type="range"] { height: 4px; border-radius: 2px; appearance: none; padding: 0; margin: 10px 0; }
        input[type="range"]::-webkit-slider-thumb { 
            appearance: none; width: 14px; height: 14px; border-radius: 50%; 
            background: var(--accent-color); cursor: pointer; border: 2px solid #222; 
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        /* å¼€å…³æ ·å¼ */
        .toggle-switch {
            position: relative; width: 44px; height: 24px;
            appearance: none; background: rgba(255,255,255,0.1); border-radius: 12px;
            transition: 0.3s; cursor: pointer; outline: none; margin: 0;
        }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px;
            background: white; border-radius: 50%; transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .toggle-switch:checked { background: var(--accent-color); }
        .toggle-switch:checked::after { transform: translateX(20px); }

        /* ä¸Šä¼ æŒ‰é’® */
        .upload-area {
            border: 2px dashed rgba(255,255,255,0.2); border-radius: 12px;
            padding: 12px; text-align: center; cursor: pointer; transition: 0.2s;
            background: rgba(0,0,0,0.2);
        }
        .upload-area:hover { border-color: var(--accent-color); background: rgba(255,215,0,0.05); }
        .upload-text { font-size: 0.8rem; color: rgba(255,255,255,0.6); }

        /* çŠ¶æ€æç¤ºæ¡ */
        #status-container {
            position: absolute; top: 20px; left: 0; right: 0; 
            display: flex; justify-content: center; pointer-events: none; z-index: 50;
        }
        #status-bar {
            display: flex; gap: 12px; background: var(--glass-bg);
            padding: 6px 8px; border-radius: 24px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .badge {
            padding: 6px 14px; border-radius: 18px; font-size: 0.85rem;
            display: flex; align-items: center; gap: 6px; opacity: 0.4; 
            transition: 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            color: rgba(255,255,255,0.8);
        }
        .badge.active { 
            opacity: 1; background: var(--accent-glow);
            color: #fff; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transform: scale(1.05);
        }

        /* åº•éƒ¨æç¤º */
        #tips {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            z-index: 10; pointer-events: none;
            font-size: 0.9rem; color: rgba(255,255,255,0.8);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            letter-spacing: 0.5px;
        }
        .key-gesture { 
            color: var(--accent-color); font-weight: 700; 
            background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;
            margin: 0 2px;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.1rem; text-shadow: 0 0 20px rgba(255,255,255,0.5); z-index: 100;
            text-align: center; line-height: 1.8; color: #ccc;
        }
    </style>
</head>
<body>

    <div id="loading">âœ¨ æ­£åœ¨è¿æ¥é­”æ³•...<br><span style="font-size:0.85em; opacity:0.6">åˆå§‹åŒ–ä¸­</span></div>

    <div class="top-bar">
        <div class="btn-icon" onclick="toggleSettings()">
            <span>âš™ï¸ è®¾ç½®</span>
        </div>
        <div class="btn-icon danger" onclick="exitToRPG()">
            <span>ğŸšª è¿”å›æ¸¸æˆ</span>
        </div>
    </div>

    <div id="settings-panel">
        <div class="panel-section">
            <div class="panel-title">ç…§ç‰‡æµ</div>
            <div class="upload-area" onclick="document.getElementById('photo-upload').click()">
                <div style="font-size: 1.4rem; margin-bottom: 5px;">ğŸ“¸</div>
                <div class="upload-text" id="upload-hint">ç‚¹å‡»ä¸Šä¼ ç…§ç‰‡<br>ç”Ÿæˆä¸“å±å›å¿†ç«èŠ±</div>
            </div>
            <input type="file" id="photo-upload" multiple accept="image/*" style="display:none" onchange="handleImageUpload(this)">
            
            <div class="control-row">
                <span class="control-label">å¯ç”¨ç…§ç‰‡ç«èŠ±</span>
                <input type="checkbox" id="photo-spark-toggle" class="toggle-switch" onchange="updateSettings()" disabled>
            </div>

            <div id="photo-advanced-controls" style="opacity: 0.4; pointer-events: none; transition: 0.3s; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-top: 5px;">
                <div class="control-group">
                    <div class="control-label" style="display:flex; justify-content:space-between;">
                        <span style="font-size:0.85rem">å–·æ¶Œå¯†åº¦</span> <span id="photo-density-val" style="color:var(--accent-color); font-size:0.85rem">ä¸­</span>
                    </div>
                    <input type="range" id="photo-density-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
                </div>
                <div class="control-group" style="margin-top:5px;">
                    <div class="control-label" style="display:flex; justify-content:space-between;">
                        <span style="font-size:0.85rem">å–·å°„é€Ÿåº¦</span> <span id="photo-speed-val" style="color:var(--accent-color); font-size:0.85rem">ä¸­</span>
                    </div>
                    <input type="range" id="photo-speed-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
                </div>
                <div class="control-group" style="margin-top:5px;">
                    <div class="control-label" style="display:flex; justify-content:space-between;">
                        <span style="font-size:0.85rem">ç…§ç‰‡å¤§å°</span> <span id="photo-size-val" style="color:var(--accent-color); font-size:0.85rem">ä¸­</span>
                    </div>
                    <input type="range" id="photo-size-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
                </div>
            </div>
        </div>

        <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 5px 0;"></div>

        <div class="panel-section">
            <div class="panel-title">æ“æ§</div>
            <div class="control-row">
                <span class="control-label">åŒæŒæ¨¡å¼ (ä¼šéå¸¸å¡)</span>
                <input type="checkbox" id="dual-mode-toggle" class="toggle-switch" onchange="updateSettings()">
            </div>
        </div>

        <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 5px 0;"></div>

        <div class="panel-section">
            <div class="panel-title">ç¯å¢ƒ</div>
            <div class="control-group">
                <div class="control-row" style="margin-bottom:8px">
                    <label class="control-label">èƒŒæ™¯æ ·å¼</label>
                    <select id="bg-style-select" onchange="updateSettings()" style="width: 100px;">
                        <option value="classic">å…‰ç‚¹</option>
                        <option value="star">æ˜Ÿè¾°</option>
                        <option value="none">çº¯é»‘</option>
                    </select>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label" style="display:flex; justify-content:space-between; margin-bottom:0px;">
                    <span>èƒŒæ™¯å¯†åº¦</span>
                    <span id="density-val" style="color:var(--accent-color)">ä¸­</span>
                </div>
                <input type="range" id="bg-density-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
            </div>
        </div>
    </div>

    <div id="status-container">
        <div id="status-bar">
            <div class="badge" id="badge-pinch">ğŸ”¥ ç‚¹ç«</div>
            <div class="badge" id="badge-peace">ğŸš€ æé€Ÿ</div>
            <div class="badge" id="badge-palm">ğŸ¨ æ¢è‰²</div>
        </div>
    </div>

    <div id="tips">
        <p><span class="key-gesture">æåˆ</span>ç‚¹ç‡ƒ Â· <span class="key-gesture">æ¯”è€¶</span>åŠ å¼º Â· <span class="key-gesture">å¼ æ‰‹</span>æ¢è‰²</p>
    </div>

    <video id="input_video"></video>
    <canvas id="bgCanvas"></canvas>
    <canvas id="fgCanvas"></canvas>

<script>
    // --- æ ¸å¿ƒå˜é‡ä¸ RPG é€šä¿¡ ---
    const videoElement = document.getElementById('input_video');
    const bgCanvas = document.getElementById('bgCanvas');
    const fgCanvas = document.getElementById('fgCanvas');
    const bgCtx = bgCanvas.getContext('2d');
    const fgCtx = fgCanvas.getContext('2d');
    const loadingDiv = document.getElementById('loading');
    let width, height;

    // é€€å‡ºå› RPG Maker
    function exitToRPG() {
        if (window.streamReference) {
            window.streamReference.getTracks().forEach(track => track.stop());
        }
        window.parent.postMessage("CLOSE_AR_WINDOW", "*");
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        bgCanvas.width = fgCanvas.width = width;
        bgCanvas.height = fgCanvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- é…ç½®ä¸çŠ¶æ€ç®¡ç† (æ¥è‡ªå‰¯æœ¬) ---
    const appSettings = {
        bgStyle: 'classic', bgDensity: 3,
        usePhotoSparks: false, photoDensity: 3, photoSpeed: 3, photoSize: 3,
        dualMode: false 
    };
    let userPhotos = []; 
    let bgIntervalId = null;

    // --- UI äº¤äº’é€»è¾‘ (æ¥è‡ªå‰¯æœ¬) ---
    function toggleSettings() {
        const panel = document.getElementById('settings-panel');
        const isFlex = panel.style.display === 'flex';
        
        if (isFlex) {
            panel.style.opacity = '0';
            panel.style.transform = 'scale(0.95) translateY(-10px)';
            setTimeout(() => panel.style.display = 'none', 200);
        } else {
            panel.style.display = 'flex';
            requestAnimationFrame(() => {
                panel.style.opacity = '1';
                panel.style.transform = 'scale(1) translateY(0)';
            });
        }
    }

    function handleImageUpload(input) {
        const files = input.files;
        if (!files.length) return;
        const hint = document.getElementById('upload-hint');
        const toggle = document.getElementById('photo-spark-toggle');
        hint.innerHTML = `å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡<br>å†æ¬¡ç‚¹å‡»å¯è¿½åŠ `;
        
        Array.from(files).forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.src = e.target.result;
                img.onload = () => {
                    userPhotos.push(img);
                    if (userPhotos.length > 0) {
                        toggle.disabled = false;
                        if (!toggle.checked) {
                            toggle.checked = true;
                            updateSettings();
                        }
                    }
                }
            };
            reader.readAsDataURL(file);
        });
    }

    function updateSettings() {
        const styleSelect = document.getElementById('bg-style-select');
        const bgDensityRange = document.getElementById('bg-density-range');
        const bgDensityLabel = document.getElementById('density-val');
        const photoToggle = document.getElementById('photo-spark-toggle');
        const photoDensityRange = document.getElementById('photo-density-range');
        const photoDensityLabel = document.getElementById('photo-density-val');
        const photoSpeedRange = document.getElementById('photo-speed-range');
        const photoSpeedLabel = document.getElementById('photo-speed-val');
        const photoSizeRange = document.getElementById('photo-size-range');
        const photoSizeLabel = document.getElementById('photo-size-val');
        const photoAdvancedDiv = document.getElementById('photo-advanced-controls');
        const dualModeToggle = document.getElementById('dual-mode-toggle');

        appSettings.bgStyle = styleSelect.value;
        appSettings.bgDensity = parseInt(bgDensityRange.value);
        appSettings.usePhotoSparks = photoToggle.checked;
        appSettings.photoDensity = parseInt(photoDensityRange.value);
        appSettings.photoSpeed = parseInt(photoSpeedRange.value);
        appSettings.photoSize = parseInt(photoSizeRange.value);
        
        // åŒæŒæ¨¡å¼é€»è¾‘
        const prevDualMode = appSettings.dualMode;
        appSettings.dualMode = dualModeToggle.checked;
        if (prevDualMode !== appSettings.dualMode && hands) {
             hands.setOptions({ maxNumHands: appSettings.dualMode ? 2 : 1 });
        }

        // æ ‡ç­¾æ›´æ–°
        const labels = ['å¾®', 'å°‘', 'ä¸­', 'å¤š', 'å¯†'];
        const speedLabels = ['æ…¢', 'è¾ƒæ…¢', 'ä¸­', 'å¿«', 'æå¿«'];
        const sizeLabels = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
        
        bgDensityLabel.innerText = labels[appSettings.bgDensity - 1];
        photoDensityLabel.innerText = labels[appSettings.photoDensity - 1];
        photoSpeedLabel.innerText = speedLabels[appSettings.photoSpeed - 1];
        photoSizeLabel.innerText = sizeLabels[appSettings.photoSize - 1];

        if (appSettings.bgStyle === 'none') {
            bgDensityRange.disabled = true;
            bgDensityRange.style.opacity = 0.5;
        } else {
            bgDensityRange.disabled = false;
            bgDensityRange.style.opacity = 1;
        }

        if (appSettings.usePhotoSparks) {
            photoAdvancedDiv.style.opacity = 1;
            photoAdvancedDiv.style.pointerEvents = 'auto';
        } else {
            photoAdvancedDiv.style.opacity = 0.4;
            photoAdvancedDiv.style.pointerEvents = 'none';
        }

        resetBgGenerator();
    }

    function resetBgGenerator() {
        if (bgIntervalId) clearInterval(bgIntervalId);
        if (appSettings.bgStyle === 'none') return;
        const baseInterval = 3500;
        const interval = baseInterval / (appSettings.bgDensity * 1.2); 

        bgIntervalId = setInterval(() => {
            const x = Math.random() * width;
            const y = height * 0.2 + Math.random() * (height * 0.4);
            const particleCount = 40 + (appSettings.bgDensity * 10);
            for(let i=0; i<particleCount; i++) {
                bgParticles.push(new Particle(x, y, 'bg'));
            }
        }, interval);
    }

    // --- ç²’å­ç³»ç»Ÿ & ç‰©ç†ç±» (æ¥è‡ªå‰¯æœ¬) ---
    class Stabilizer {
        constructor(minCutoff = 0.1, beta = 2.0) {
            this.x = 0; this.y = 0;
            this.dx = 0; this.dy = 0;
            this.lastX = 0; this.lastY = 0;
            this.lastTime = performance.now();
            this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = 1.0; 
        }

        update(targetX, targetY) {
            const now = performance.now();
            const dt = (now - this.lastTime) / 1000;
            this.lastTime = now;
            if (dt <= 0) return { x: this.x, y: this.y };

            let dx = (targetX - this.lastX) / dt;
            let dy = (targetY - this.lastY) / dt;
            let dAlpha = this.alpha(this.dCutoff, dt);
            this.dx = this.lerp(this.dx, dx, dAlpha);
            this.dy = this.lerp(this.dy, dy, dAlpha);

            let cutoff = this.minCutoff + this.beta * Math.abs(Math.sqrt(this.dx*this.dx + this.dy*this.dy));
            let alpha = this.alpha(cutoff, dt);

            this.x = this.lerp(this.x, targetX, alpha);
            this.y = this.lerp(this.y, targetY, alpha);
            this.lastX = targetX; this.lastY = targetY;
            return { x: this.x, y: this.y };
        }
        alpha(cutoff, dt) { let tau = 1.0 / (2 * Math.PI * cutoff); return 1.0 / (1.0 + tau / dt); }
        lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
    }

    class ValueStabilizer {
        constructor(smoothing = 0.1) { this.val = 0; this.smoothing = smoothing; }
        update(target) { this.val += (target - this.val) * this.smoothing; return this.val; }
    }

    const colors = [
        { hue: 45, sat: 100, light: 75 },
        { hue: 190, sat: 100, light: 70 },   
        { hue: 320, sat: 100, light: 70 },   
        { hue: 140, sat: 100, light: 75 },   
        { hue: 0, sat: 0, light: 100 }       
    ];
    let currentColorIdx = 0;

    class Particle {
        constructor(x, y, type, handVel = {x:0, y:0}, isTurbo = false) {
            this.x = x; this.y = y; this.type = type;
            const angle = Math.random() * Math.PI * 2;
            
            // --- èƒŒæ™¯ç²’å­ ---
            if (type === 'bg') {
                const speed = Math.random() * 4 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 0.05; this.friction = 0.96;
                this.life = 1.0; this.decay = Math.random() * 0.015 + 0.01;
                this.hue = Math.random() * 360;
                this.size = Math.random() * 2 + 1;
                this.style = appSettings.bgStyle; 
                this.rot = Math.random() * 360;
                return;
            } 
            
            // --- ä»™å¥³æ£’ç²’å­ ---
            this.isPhoto = appSettings.usePhotoSparks && userPhotos.length > 0;
            
            if (this.isPhoto) {
                this.img = userPhotos[Math.floor(Math.random() * userPhotos.length)];
                const speedMult = 0.2 + (appSettings.photoSpeed * 0.16);
                const baseSpeed = (isTurbo ? (Math.random() * 6 + 3) : (Math.random() * 3 + 1)) * speedMult;
                
                this.vx = Math.cos(angle) * baseSpeed + (handVel.x * 0.4);
                this.vy = Math.sin(angle) * baseSpeed + (handVel.y * 0.4);
                
                this.gravity = 0.1; 
                this.friction = 0.96;
                this.life = 1.0;
                this.decay = Math.random() * 0.01 + 0.005; 
                
                // ç…§ç‰‡å°ºå¯¸æ§åˆ¶
                let sizeMult = 1.0;
                if (appSettings.photoSize === 1) sizeMult = 0.4;
                else if (appSettings.photoSize === 2) sizeMult = 0.7;
                else if (appSettings.photoSize === 3) sizeMult = 1.0;
                else if (appSettings.photoSize === 4) sizeMult = 1.6;
                else if (appSettings.photoSize === 5) sizeMult = 2.5;

                const aspect = this.img.width / this.img.height;
                const baseSizeRef = isTurbo ? 60 : 40; 
                const finalBaseSize = baseSizeRef * sizeMult;

                this.w = finalBaseSize * (Math.random() * 0.4 + 0.8);
                this.h = this.w / aspect;
                this.rot = Math.random() * 360;
                this.vRot = (Math.random() - 0.5) * 5; 
            } else {
                // æ™®é€šç²’å­
                const baseSpeed = isTurbo ? (Math.random() * 10 + 3) : (Math.random() * 5 + 1);
                this.vx = Math.cos(angle) * baseSpeed + (handVel.x * 0.3);
                this.vy = Math.sin(angle) * baseSpeed + (handVel.y * 0.3);
                this.gravity = 0.2; 
                this.friction = 0.94;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.01;
                
                const theme = colors[currentColorIdx];
                this.hue = theme.hue + (Math.random() * 30 - 15);
                this.sat = theme.sat;
                this.light = theme.light + Math.random() * 20;
                this.size = (Math.random() * 2.5 + 1) * (isTurbo ? 1.8 : 1.0);
            }
        }

        update() {
            this.vx *= this.friction; this.vy *= this.friction;
            this.vy += this.gravity; this.x += this.vx; this.y += this.vy;
            this.life -= this.decay;
            if (this.isPhoto) this.rot += this.vRot;
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            
            if (this.type === 'bg') {
                ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.life})`;
                if (this.style === 'star') {
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rot * Math.PI / 180);
                    this.rot += 2; 
                    this.drawStar(ctx, 0, 0, 4, this.size * 2, this.size * 0.8);
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                }
            } else if (this.isPhoto) {
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rot * Math.PI / 180);
                ctx.fillStyle = "#fff";
                const padding = Math.max(2, this.w * 0.05);
                ctx.fillRect(-this.w/2 - padding, -this.h/2 - padding, this.w + padding*2, this.h + padding*2);
                ctx.drawImage(this.img, -this.w/2, -this.h/2, this.w, this.h);
            } else {
                ctx.fillStyle = `hsl(${this.hue}, ${this.sat}%, ${this.light}%)`;
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = this.size > 2 ? 25 : 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx, y = cy;
            let step = Math.PI / spikes;
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y); rot += step;
                x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y); rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill();
        }
    }

    let bgParticles = [];
    let fgParticles = [];

    // --- æ‰‹åŠ¿ä¸ç»˜åˆ¶é€»è¾‘ (æ¥è‡ªå‰¯æœ¬) ---
    class HandInstance {
        constructor() {
            this.pos = { x: -100, y: -100 };
            this.lastPos = { x: -100, y: -100 };
            this.velocity = { x: 0, y: 0 };
            this.stabilizer = new Stabilizer(0.05, 0.8);
            this.angleStabilizer = new ValueStabilizer(0.12);
            this.stickAngle = 0;
            this.gesture = { isDetected: false, isPinching: false, isTurbo: false, isPalmOpen: false };
            this.lastSeen = 0;
        }

        update(landmarks, now) {
            this.lastSeen = now;
            this.gesture.isDetected = true;

            const p9 = landmarks[9], p0 = landmarks[0];
            const rawNormX = p9.x * 0.75 + p0.x * 0.25;
            const rawNormY = p9.y * 0.75 + p0.y * 0.25;
            const rawX = (1 - rawNormX) * width;
            const rawY = rawNormY * height;

            const smoothed = this.stabilizer.update(rawX, rawY);
            this.pos.x = smoothed.x;
            this.pos.y = smoothed.y;

            this.velocity.x = this.pos.x - this.lastPos.x;
            this.velocity.y = this.pos.y - this.lastPos.y;
            this.lastPos.x = this.pos.x;
            this.lastPos.y = this.pos.y;

            let targetTilt = Math.max(-35, Math.min(35, -this.velocity.x * 2.0));
            this.stickAngle = this.angleStabilizer.update(targetTilt);

            this.detectGestures(landmarks);
        }

        detectGestures(landmarks) {
            const indexTip = landmarks[8], thumbTip = landmarks[4];
            const indexPip = landmarks[6], middlePip = landmarks[10], ringPip = landmarks[14], pinkyPip = landmarks[18];
            const tipsY = [landmarks[8].y, landmarks[12].y, landmarks[16].y, landmarks[20].y];

            const pinchDist = Math.hypot((indexTip.x - thumbTip.x), (indexTip.y - thumbTip.y));
            this.gesture.isPinching = pinchDist < 0.08; 

            const isOpen = [
                tipsY[0] < indexPip.y,
                tipsY[1] < middlePip.y,
                tipsY[2] < ringPip.y,
                tipsY[3] < pinkyPip.y
            ];

            this.gesture.isTurbo = isOpen[0] && isOpen[1] && !isOpen[2] && !isOpen[3];
            this.gesture.isPalmOpen = isOpen[0] && isOpen[1] && isOpen[2] && isOpen[3];
        }
    }

    const handInstances = new Map();
    handInstances.set('Left', new HandInstance());
    handInstances.set('Right', new HandInstance());
    
    let globalGestureState = { isPinching: false, isTurbo: false, isPalmOpen: false, lastColorChangeTime: 0 };
    const badges = {
        pinch: document.getElementById('badge-pinch'),
        peace: document.getElementById('badge-peace'),
        palm: document.getElementById('badge-palm')
    };

    resetBgGenerator();

    function drawSparklerStick(hand) {
        fgCtx.save();
        fgCtx.translate(hand.pos.x, hand.pos.y);
        fgCtx.rotate(hand.stickAngle * Math.PI / 180);

        fgCtx.strokeStyle = "#e0e0e0";
        fgCtx.lineCap = "round";
        fgCtx.lineWidth = 12; 
        fgCtx.beginPath(); fgCtx.moveTo(0, 0); fgCtx.lineTo(0, 180); fgCtx.stroke();
        
        fgCtx.strokeStyle = "#a0a0a0";
        fgCtx.lineWidth = 4;
        fgCtx.beginPath(); fgCtx.moveTo(0, 20); fgCtx.lineTo(0, 170); fgCtx.stroke();

        fgCtx.fillStyle = "#ffd700";
        fgCtx.fillRect(-7, 50, 14, 4);
        fgCtx.fillRect(-7, 80, 14, 4);

        const shouldEmit = hand.gesture.isPinching || hand.gesture.isTurbo;
        fgCtx.fillStyle = shouldEmit ? "#fff" : "#666";
        fgCtx.fillRect(-8, -15, 16, 45); 

        if (shouldEmit) {
            fgCtx.shadowBlur = hand.gesture.isTurbo ? 60 : 35;
            fgCtx.shadowColor = "#ffeb3b";
            fgCtx.fillStyle = "#fff";
            fgCtx.beginPath(); 
            fgCtx.arc(0, 0, hand.gesture.isTurbo ? 16 : 10, 0, Math.PI*2); 
            fgCtx.fill();
        }
        fgCtx.restore();
    }
    
    function updateGlobalStateAndUI() {
        let anyPinch = false, anyTurbo = false, anyPalm = false;
        const now = Date.now();
        
        for (let hand of handInstances.values()) {
            if (now - hand.lastSeen < 200) {
                if (hand.gesture.isPinching) anyPinch = true;
                if (hand.gesture.isTurbo) anyTurbo = true;
                if (hand.gesture.isPalmOpen) anyPalm = true;
            }
        }

        globalGestureState.isPinching = anyPinch;
        globalGestureState.isTurbo = anyTurbo;
        globalGestureState.isPalmOpen = anyPalm;

        if (anyPalm && (now - globalGestureState.lastColorChangeTime > 1200)) {
            globalGestureState.lastColorChangeTime = now;
            currentColorIdx = (currentColorIdx + 1) % colors.length;
            const flash = document.createElement('div');
            flash.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;background:hsl(${colors[currentColorIdx].hue},50%,50%);opacity:0.2;pointer-events:none;z-index:999;transition:0.3s`;
            document.body.appendChild(flash);
            setTimeout(() => { flash.style.opacity = 0; setTimeout(()=>flash.remove(),300); }, 50);
        }

        if (globalGestureState.isPinching) badges.pinch.classList.add('active'); else badges.pinch.classList.remove('active');
        if (globalGestureState.isTurbo) badges.peace.classList.add('active'); else badges.peace.classList.remove('active');
        if (globalGestureState.isPalmOpen) badges.palm.classList.add('active'); else badges.palm.classList.remove('active');
    }

    // --- MediaPipe åˆå§‹åŒ– (ã€æ ¸å¿ƒä¿®å¤ 2ã€‘æœ¬åœ°è·¯å¾„) ---
    const hands = new Hands({
        locateFile: (file) => {
            console.log(`åŠ è½½æœ¬åœ°æ¨¡å‹: mediapipe/${file}`);
            return `mediapipe/${file}`;
        }
    });
    
    hands.setOptions({
        maxNumHands: 1, // åˆå§‹å•æ‰‹
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        // éšè— Loading (å¦‚æœè¿˜åœ¨æ˜¾ç¤º)
        loadingDiv.style.display = 'none';
        
        const now = Date.now();
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const landmarks = results.multiHandLandmarks[i];
                let label = 'Right';
                if (results.multiHandedness && results.multiHandedness[i]) {
                    label = results.multiHandedness[i].label; 
                }
                if (handInstances.has(label)) {
                    handInstances.get(label).update(landmarks, now);
                }
            }
        }
        updateGlobalStateAndUI();
    });

    // --- æ‘„åƒå¤´å¯åŠ¨ (ã€æ ¸å¿ƒä¿®å¤ 3ã€‘æ‰‹åŠ¨å¯åŠ¨ä»¥é¿å… NW.js å¡æ­») ---
    // æ›¿æ¢äº†åŸæ¥çš„ const camera = new Camera(...)
    async function startCamera() {
        try {
            loadingDiv.innerHTML = "âœ¨ æ­£åœ¨è¿æ¥æ‘„åƒå¤´...";
            
            // 1. è·å–æµ
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: "user" },
                audio: false
            });

            // 2. æ’­æ”¾è§†é¢‘
            videoElement.srcObject = stream;
            window.streamReference = stream; // ä¿å­˜å¼•ç”¨ä»¥ä¾¿å…³é—­
            
            await new Promise((resolve) => videoElement.onloadedmetadata = resolve);
            videoElement.play();

            // 3. å¼€å¯å¾ªç¯æ£€æµ‹
            loadingDiv.innerHTML = "âœ¨ æ­£åœ¨åŠ è½½æœ¬åœ° AI æ¨¡å‹...";
            
            const sendFrame = async () => {
                if (!videoElement.paused && !videoElement.ended) {
                    await hands.send({image: videoElement});
                }
                requestAnimationFrame(sendFrame);
            };
            sendFrame();

        } catch (error) {
            console.error(error);
            loadingDiv.innerHTML = `âš ï¸ å¯åŠ¨å¤±è´¥<br><span style='font-size:0.5em'>${error.message}</span>`;
            alert("è¯·ç¡®ä¿ package.json å·²é…ç½® fake-ui å‚æ•°");
        }
    }

    // --- å¯åŠ¨ä¸»ç¨‹åº ---
    startCamera();

    // --- æ¸²æŸ“å¾ªç¯ ---
    function loop() {
        requestAnimationFrame(loop);

        bgCtx.fillStyle = 'rgba(5, 5, 8, 0.25)';
        bgCtx.fillRect(0, 0, width, height);
        fgCtx.clearRect(0, 0, width, height);

        // èƒŒæ™¯ç²’å­
        for (let i = bgParticles.length - 1; i >= 0; i--) {
            let p = bgParticles[i]; p.update(); p.draw(bgCtx);
            if (p.life <= 0) bgParticles.splice(i, 1);
        }

        const now = Date.now();

        // æ‰‹éƒ¨ä¸ç«èŠ±
        for (let hand of handInstances.values()) {
            if (now - hand.lastSeen > 200) continue;

            drawSparklerStick(hand);

            const shouldEmit = hand.gesture.isPinching || hand.gesture.isTurbo;
            if (shouldEmit) {
                const isPhotoMode = appSettings.usePhotoSparks && userPhotos.length > 0;
                let count = 0;

                if (isPhotoMode) {
                    const density = appSettings.photoDensity;
                    let spawnChance = density * 0.03; 
                    if (hand.gesture.isTurbo) spawnChance *= 2.0;
                    if (Math.random() < spawnChance) count = 1;
                } else {
                    count = hand.gesture.isTurbo ? 12 : 6;
                }

                for(let i=0; i<count; i++) {
                    fgParticles.push(new Particle(
                        hand.pos.x, hand.pos.y, 'fg', 
                        hand.velocity, hand.gesture.isTurbo
                    ));
                }
            }
        }

        // å‰æ™¯ç²’å­
        for (let i = fgParticles.length - 1; i >= 0; i--) {
            let p = fgParticles[i]; p.update(); p.draw(fgCtx);
            if (p.life <= 0) fgParticles.splice(i, 1);
        }
    }
    loop();

</script>
</body>
</html>
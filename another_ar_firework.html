<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR é­”æ³•ä»™å¥³æ£’</title>

    <!-- MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- å…¼å®¹ RPG Maker MV/MZ (NW.js) çš„ç¯å¢ƒè¡¥ä¸ -->
    <script>
    if (typeof process === 'object' && typeof require === 'function') {
        window._oldModule = window.module;
        window.module = undefined; window.exports = undefined; window.__dirname = ''; 
    }
    </script>

    <style>
        /* --- æ ¸å¿ƒæ ·å¼ --- */
        :root {
            --glass-bg: rgba(20, 20, 28, 0.75);
            --glass-border: rgba(255, 255, 255, 0.12);
            --accent-color: #ffd700;
            --accent-glow: rgba(255, 215, 0, 0.4);
            --text-main: #ffffff;
        }

        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            color: var(--text-main);
            user-select: none; -webkit-user-select: none;
        }
        canvas { position: absolute; top: 0; left: 0; }
        
        /* å…³é”®ï¼šéšè—è§†é¢‘ä½†ä¿ç•™å ä½ */
        #input_video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        /* --- å¯åŠ¨é®ç½©å±‚ (ç§»æ¤è‡ª AR ç‰ˆ) --- */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s; backdrop-filter: blur(10px);
        }

        .tutorial-box {
            background: rgba(20, 20, 30, 0.8); border: 1px solid var(--accent-color);
            padding: 25px 30px; border-radius: 20px; text-align: left; margin-bottom: 30px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.2); max-width: 85%; line-height: 1.6;
        }
        .tutorial-box h2 { margin: 0 0 15px 0; color: var(--accent-color); text-align: center; }
        .tutorial-box li { margin-bottom: 10px; color: #ddd; font-size: 0.95rem; }
        .highlight { color: #fff; font-weight: bold; background: rgba(255,215,0,0.3); padding: 2px 6px; border-radius: 4px; }

        #start-btn {
            padding: 16px 40px; font-size: 1.2rem; background: var(--accent-color); color: #000;
            border: none; border-radius: 50px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 25px var(--accent-glow); transition: 0.3s;
        }
        #start-btn:hover { transform: scale(1.05); }

        /* --- UI æ ·å¼ --- */
        .btn-icon {
            background: var(--glass-bg); border: 1px solid var(--glass-border);
            color: white; padding: 10px 16px; border-radius: 12px;
            cursor: pointer; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            font-size: 0.95rem; display: flex; align-items: center; gap: 8px;
            pointer-events: auto; transition: 0.3s;
        }
        .btn-icon:hover { background: rgba(255, 255, 255, 0.1); transform: translateY(-2px); }
        .btn-icon.danger { border-color: rgba(255, 100, 100, 0.3); }
        
        .top-bar {
            position: absolute; top: 20px; left: 24px; right: 24px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 60; pointer-events: none;
        }

        #settings-panel {
            position: absolute; top: 70px; left: 24px; z-index: 60;
            background: rgba(18, 18, 24, 0.9); border: 1px solid var(--glass-border);
            padding: 20px; border-radius: 16px; width: 260px; display: none; 
            flex-direction: column; gap: 15px; pointer-events: auto;
            backdrop-filter: blur(20px); max-height: 80vh; overflow-y: auto;
        }
        
        .panel-section { display: flex; flex-direction: column; gap: 10px; }
        .panel-title { font-size: 0.8rem; text-transform: uppercase; color: rgba(255,255,255,0.5); font-weight: 600; }
        .control-row { display: flex; justify-content: space-between; align-items: center; }
        
        select, input[type="range"] {
            background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1);
            color: white; padding: 6px; border-radius: 8px; outline: none; width: 100%;
        }
        input[type="range"] { height: 4px; padding: 0; margin: 10px 0; appearance: none; }
        input[type="range"]::-webkit-slider-thumb { 
            appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent-color); 
        }

        .toggle-switch {
            position: relative; width: 44px; height: 24px; appearance: none; 
            background: rgba(255,255,255,0.1); border-radius: 12px; transition: 0.3s; outline: none;
        }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px;
            background: white; border-radius: 50%; transition: 0.3s;
        }
        .toggle-switch:checked { background: var(--accent-color); }
        .toggle-switch:checked::after { transform: translateX(20px); }

        .upload-area {
            border: 2px dashed rgba(255,255,255,0.2); border-radius: 12px; padding: 12px; 
            text-align: center; cursor: pointer; background: rgba(0,0,0,0.2);
        }
        .upload-text { font-size: 0.8rem; color: rgba(255,255,255,0.6); }

        #status-container { position: absolute; top: 20px; left: 0; right: 0; display: flex; justify-content: center; pointer-events: none; z-index: 50; }
        #status-bar { display: flex; gap: 12px; background: var(--glass-bg); padding: 6px 8px; border-radius: 24px; border: 1px solid var(--glass-border); }
        .badge { padding: 6px 14px; border-radius: 18px; font-size: 0.85rem; opacity: 0.4; transition: 0.4s; color: rgba(255,255,255,0.8); }
        .badge.active { opacity: 1; background: var(--accent-glow); color: #fff; transform: scale(1.05); }

        #tips { position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10; font-size: 0.9rem; color: rgba(255,255,255,0.8); pointer-events: none; }
        .key-gesture { color: var(--accent-color); font-weight: 700; background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; }
    </style>
</head>
<body>

    <!-- ç§»æ¤è‡ª AR ç‰ˆæœ¬çš„å¯åŠ¨é®ç½© -->
    <div id="start-overlay">
        <div class="tutorial-box">
            <h2>âœ¨ é­”æ³•å¯åŠ¨æŒ‡å— âœ¨</h2>
            <ul>
                <li>ğŸ‘‹ <b>æ‰‹åŠ¿</b>ï¼šå¯¹å‡†æ‘„åƒå¤´ï¼Œä½ çš„é£ŸæŒ‡å°±æ˜¯<span class="highlight">é­”æ³•æ£’</span>ã€‚</li>
                <li>ğŸ¤ <b>æåˆ</b>ï¼šé£ŸæŒ‡ä¸æ‹‡æŒ‡æåˆï¼Œç‚¹ç‡ƒç«èŠ±ã€‚</li>
                <li>âœŒï¸ <b>æ¯”è€¶</b>ï¼šæ¯”å‡ºå‰ªåˆ€æ‰‹ï¼Œé‡Šæ”¾è¶…çº§åŠ å€çš„ç«èŠ±ã€‚</li>
                <li>ğŸ– <b>å¼ æ‰‹</b>ï¼šäº”æŒ‡å¼ å¼€ï¼Œåˆ‡æ¢ç«èŠ±é¢œè‰²ã€‚</li>
            </ul>
        </div>
        <button id="start-btn" onclick="startApp()">âœ¨ å¼€å¯é­”æ³• âœ¨</button>
        <div id="loading-text" style="display:none; margin-top: 15px; color:#aaa;">æ­£åœ¨åŠ è½½é­”æ³•å¼•æ“...</div>
    </div>

    <div class="top-bar">
        <div class="btn-icon" onclick="toggleSettings()">
            <span>âš™ï¸ è®¾ç½®</span>
        </div>
        <div class="btn-icon danger" onclick="exitToRPG()">
            <span>ğŸšª è¿”å›æ¸¸æˆ</span>
        </div>
    </div>

    <!-- è®¾ç½®é¢æ¿ -->
    <div id="settings-panel">
        <div class="panel-section">
            <div class="panel-title">ç…§ç‰‡æµ</div>
            <div class="upload-area" onclick="document.getElementById('photo-upload').click()">
                <div style="font-size: 1.4rem; margin-bottom: 5px;">ğŸ“¸</div>
                <div class="upload-text" id="upload-hint">ç‚¹å‡»ä¸Šä¼ ç…§ç‰‡<br>ç”Ÿæˆä¸“å±å›å¿†ç«èŠ±</div>
            </div>
            <input type="file" id="photo-upload" multiple accept="image/*" style="display:none" onchange="handleImageUpload(this)">
            
            <div class="control-row">
                <span class="control-label" style="font-size:0.9rem; color:#eee">å¯ç”¨ç…§ç‰‡ç«èŠ±</span>
                <input type="checkbox" id="photo-spark-toggle" class="toggle-switch" onchange="updateSettings()" disabled>
            </div>

            <div id="photo-advanced-controls" style="opacity: 0.4; pointer-events: none; transition: 0.3s; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-top: 5px;">
                <div class="control-group">
                    <div style="display:flex; justify-content:space-between; font-size:0.85rem; color:#ddd">
                        <span>å–·æ¶Œå¯†åº¦</span> <span id="photo-density-val" style="color:var(--accent-color)">ä¸­</span>
                    </div>
                    <input type="range" id="photo-density-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
                </div>
                <div class="control-group" style="margin-top:5px;">
                    <div style="display:flex; justify-content:space-between; font-size:0.85rem; color:#ddd">
                        <span>å–·å°„é€Ÿåº¦</span> <span id="photo-speed-val" style="color:var(--accent-color)">ä¸­</span>
                    </div>
                    <input type="range" id="photo-speed-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
                </div>
                <div class="control-group" style="margin-top:5px;">
                    <div style="display:flex; justify-content:space-between; font-size:0.85rem; color:#ddd">
                        <span>ç…§ç‰‡å¤§å°</span> <span id="photo-size-val" style="color:var(--accent-color)">ä¸­</span>
                    </div>
                    <input type="range" id="photo-size-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
                </div>
            </div>
        </div>

        <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 5px 0;"></div>

        <div class="panel-section">
            <div class="panel-title">æ“æ§</div>
            <div class="control-row">
                <span class="control-label" style="font-size:0.9rem; color:#eee">åŒæŒæ¨¡å¼ (æ¶ˆè€—æ€§èƒ½)</span>
                <input type="checkbox" id="dual-mode-toggle" class="toggle-switch" onchange="updateSettings()">
            </div>
        </div>

        <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 5px 0;"></div>

        <div class="panel-section">
            <div class="panel-title">ç¯å¢ƒ</div>
            <div class="control-group">
                <div class="control-row" style="margin-bottom:8px">
                    <label style="font-size:0.9rem; color:#eee">èƒŒæ™¯æ ·å¼</label>
                    <select id="bg-style-select" onchange="updateSettings()" style="width: 100px;">
                        <option value="classic">å…‰ç‚¹</option>
                        <option value="star">æ˜Ÿè¾°</option>
                        <option value="none">çº¯é»‘</option>
                    </select>
                </div>
            </div>
            <div class="control-group">
                <div style="display:flex; justify-content:space-between; margin-bottom:0px; font-size:0.9rem; color:#eee">
                    <span>èƒŒæ™¯å¯†åº¦</span>
                    <span id="density-val" style="color:var(--accent-color)">ä¸­</span>
                </div>
                <input type="range" id="bg-density-range" min="1" max="5" value="3" step="1" oninput="updateSettings()">
            </div>
        </div>
    </div>

    <div id="status-container">
        <div id="status-bar">
            <div class="badge" id="badge-pinch">ğŸ”¥ ç‚¹ç«</div>
            <div class="badge" id="badge-peace">ğŸš€ æé€Ÿ</div>
            <div class="badge" id="badge-palm">ğŸ¨ æ¢è‰²</div>
        </div>
    </div>

    <div id="tips">
        <p><span class="key-gesture">æåˆ</span>ç‚¹ç‡ƒ Â· <span class="key-gesture">æ¯”è€¶</span>åŠ å¼º Â· <span class="key-gesture">å¼ æ‰‹</span>æ¢è‰²</p>
    </div>

    <video id="input_video" playsinline webkit-playsinline muted></video>
    <canvas id="bgCanvas"></canvas>
    <canvas id="fgCanvas"></canvas>

<script>
    // --- æ ¸å¿ƒå˜é‡ ---
    const videoElement = document.getElementById('input_video');
    const bgCanvas = document.getElementById('bgCanvas');
    const fgCanvas = document.getElementById('fgCanvas');
    const bgCtx = bgCanvas.getContext('2d');
    const fgCtx = fgCanvas.getContext('2d');
    const loadingText = document.getElementById('loading-text');
    let width, height;
    let hands; // AI å®ä¾‹

    // --- é…ç½®ä¸çŠ¶æ€ç®¡ç† ---
    const appSettings = {
        bgStyle: 'classic', bgDensity: 3,
        usePhotoSparks: false, photoDensity: 3, photoSpeed: 3, photoSize: 3,
        dualMode: false 
    };
    let userPhotos = []; 
    let bgIntervalId = null;

    // --- çª—å£é€‚é… ---
    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        bgCanvas.width = fgCanvas.width = width;
        bgCanvas.height = fgCanvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- å¯åŠ¨é€»è¾‘ (ç§»æ¤ä¿®å¤ç‰ˆ) ---
    async function startApp() {
        const btn = document.getElementById('start-btn');
        btn.style.display = 'none';
        loadingText.style.display = 'block';

        try {
            // 1. åˆå§‹åŒ– MediaPipe
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults); // ç»‘å®šç»“æœå›è°ƒ

            // 2. å¯åŠ¨æ‘„åƒå¤´
            // ä½¿ç”¨ä¸ ar_firework.html ç›¸åŒçš„å‚æ•°
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: "user" },
                audio: false
            });

            videoElement.srcObject = stream;
            
            // 3. å¿…é¡»åœ¨ç”¨æˆ·äº¤äº’åè°ƒç”¨ play (Safari/RPG Maker ä¿®å¤)
            await new Promise((resolve) => videoElement.onloadedmetadata = resolve);
            await videoElement.play();

            // 4. éšè—é®ç½©ï¼Œå¯åŠ¨å¾ªç¯
            document.getElementById('start-overlay').style.opacity = '0';
            setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);

            // 5. å¯åŠ¨å¸§å¤„ç†å¾ªç¯
            loop(); // å¯åŠ¨ç»˜å›¾å¾ªç¯
            processVideoLoop(); // å¯åŠ¨ AI è¯†åˆ«å¾ªç¯

        } catch (e) {
            console.error(e);
            loadingText.innerHTML = `<span style="color:red">å¯åŠ¨å¤±è´¥: ${e.message}<br>è¯·ç¡®ä¿å…è®¸æ‘„åƒå¤´æƒé™</span>`;
            btn.style.display = 'block';
            btn.innerText = "é‡è¯•";
        }
    }

    async function processVideoLoop() {
        if (!videoElement.paused && !videoElement.ended && videoElement.readyState >= 2) {
            await hands.send({image: videoElement});
        }
        requestAnimationFrame(processVideoLoop);
    }

    // --- UI äº¤äº’é€»è¾‘ ---
    function toggleSettings() {
        const panel = document.getElementById('settings-panel');
        const isFlex = panel.style.display === 'flex';
        if (isFlex) {
            panel.style.opacity = '0';
            panel.style.transform = 'scale(0.95) translateY(-10px)';
            setTimeout(() => panel.style.display = 'none', 200);
        } else {
            panel.style.display = 'flex';
            requestAnimationFrame(() => {
                panel.style.opacity = '1';
                panel.style.transform = 'scale(1) translateY(0)';
            });
        }
    }

    function handleImageUpload(input) {
        const files = input.files;
        if (!files.length) return;
        const hint = document.getElementById('upload-hint');
        const toggle = document.getElementById('photo-spark-toggle');
        hint.innerHTML = `å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡<br>å†æ¬¡ç‚¹å‡»å¯è¿½åŠ `;
        
        Array.from(files).forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.src = e.target.result;
                img.onload = () => {
                    userPhotos.push(img);
                    if (userPhotos.length > 0) {
                        toggle.disabled = false;
                        if (!toggle.checked) {
                            toggle.checked = true;
                            updateSettings();
                        }
                    }
                }
            };
            reader.readAsDataURL(file);
        });
    }

    function updateSettings() {
        // è¯»å–æ‰€æœ‰ UI æ§ä»¶çš„å€¼
        appSettings.bgStyle = document.getElementById('bg-style-select').value;
        appSettings.bgDensity = parseInt(document.getElementById('bg-density-range').value);
        appSettings.usePhotoSparks = document.getElementById('photo-spark-toggle').checked;
        appSettings.photoDensity = parseInt(document.getElementById('photo-density-range').value);
        appSettings.photoSpeed = parseInt(document.getElementById('photo-speed-range').value);
        appSettings.photoSize = parseInt(document.getElementById('photo-size-range').value);
        
        // åŒæŒæ¨¡å¼é€»è¾‘
        const prevDualMode = appSettings.dualMode;
        appSettings.dualMode = document.getElementById('dual-mode-toggle').checked;
        if (prevDualMode !== appSettings.dualMode && hands) {
             hands.setOptions({ maxNumHands: appSettings.dualMode ? 2 : 1 });
        }

        // æ›´æ–°æ ‡ç­¾æ–‡å­—
        const labels = ['å¾®', 'å°‘', 'ä¸­', 'å¤š', 'å¯†'];
        const speedLabels = ['æ…¢', 'è¾ƒæ…¢', 'ä¸­', 'å¿«', 'æå¿«'];
        const sizeLabels = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
        
        document.getElementById('density-val').innerText = labels[appSettings.bgDensity - 1];
        document.getElementById('photo-density-val').innerText = labels[appSettings.photoDensity - 1];
        document.getElementById('photo-speed-val').innerText = speedLabels[appSettings.photoSpeed - 1];
        document.getElementById('photo-size-val').innerText = sizeLabels[appSettings.photoSize - 1];

        // å¯ç”¨/ç¦ç”¨é€»è¾‘
        const advanced = document.getElementById('photo-advanced-controls');
        if (appSettings.usePhotoSparks) {
            advanced.style.opacity = 1; advanced.style.pointerEvents = 'auto';
        } else {
            advanced.style.opacity = 0.4; advanced.style.pointerEvents = 'none';
        }

        resetBgGenerator();
    }

    function exitToRPG() {
        if (videoElement.srcObject) videoElement.srcObject.getTracks().forEach(t => t.stop());
        window.parent.postMessage("CLOSE_AR_WINDOW", "*");
    }

    function resetBgGenerator() {
        if (bgIntervalId) clearInterval(bgIntervalId);
        if (appSettings.bgStyle === 'none') return;
        const baseInterval = 3500;
        const interval = baseInterval / (appSettings.bgDensity * 1.2); 

        bgIntervalId = setInterval(() => {
            const x = Math.random() * width;
            const y = height * 0.2 + Math.random() * (height * 0.4);
            const particleCount = 40 + (appSettings.bgDensity * 10);
            for(let i=0; i<particleCount; i++) {
                bgParticles.push(new Particle(x, y, 'bg'));
            }
        }, interval);
    }

    // --- ç²’å­ä¸ç‰©ç†ç³»ç»Ÿ ---
    class Stabilizer {
        constructor(minCutoff = 0.1, beta = 2.0) {
            this.x = 0; this.y = 0; this.dx = 0; this.dy = 0;
            this.lastX = 0; this.lastY = 0; this.lastTime = performance.now();
            this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = 1.0; 
        }
        update(targetX, targetY) {
            const now = performance.now();
            const dt = (now - this.lastTime) / 1000;
            this.lastTime = now;
            if (dt <= 0) return { x: this.x, y: this.y };
            let dx = (targetX - this.lastX) / dt;
            let dy = (targetY - this.lastY) / dt;
            let dAlpha = this.alpha(this.dCutoff, dt);
            this.dx = this.lerp(this.dx, dx, dAlpha);
            this.dy = this.lerp(this.dy, dy, dAlpha);
            let cutoff = this.minCutoff + this.beta * Math.abs(Math.sqrt(this.dx*this.dx + this.dy*this.dy));
            let alpha = this.alpha(cutoff, dt);
            this.x = this.lerp(this.x, targetX, alpha);
            this.y = this.lerp(this.y, targetY, alpha);
            this.lastX = targetX; this.lastY = targetY;
            return { x: this.x, y: this.y };
        }
        alpha(cutoff, dt) { let tau = 1.0 / (2 * Math.PI * cutoff); return 1.0 / (1.0 + tau / dt); }
        lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
    }
    class ValueStabilizer {
        constructor(smoothing = 0.1) { this.val = 0; this.smoothing = smoothing; }
        update(target) { this.val += (target - this.val) * this.smoothing; return this.val; }
    }

    const colors = [
        { hue: 45, sat: 100, light: 75 },
        { hue: 190, sat: 100, light: 70 },   
        { hue: 320, sat: 100, light: 70 },   
        { hue: 140, sat: 100, light: 75 },   
        { hue: 0, sat: 0, light: 100 }        
    ];
    let currentColorIdx = 0;

    class Particle {
        constructor(x, y, type, handVel = {x:0, y:0}, isTurbo = false) {
            this.x = x; this.y = y; this.type = type;
            const angle = Math.random() * Math.PI * 2;
            
            // --- èƒŒæ™¯ç²’å­ ---
            if (type === 'bg') {
                const speed = Math.random() * 4 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 0.05; this.friction = 0.96;
                this.life = 1.0; this.decay = Math.random() * 0.015 + 0.01;
                this.hue = Math.random() * 360;
                this.size = Math.random() * 2 + 1;
                this.style = appSettings.bgStyle; 
                this.rot = Math.random() * 360;
                return;
            } 
            
            // --- ä»™å¥³æ£’ç²’å­ (æ”¯æŒç…§ç‰‡æ¨¡å¼) ---
            this.isPhoto = appSettings.usePhotoSparks && userPhotos.length > 0;
            
            if (this.isPhoto) {
                this.img = userPhotos[Math.floor(Math.random() * userPhotos.length)];
                const speedMult = 0.2 + (appSettings.photoSpeed * 0.16);
                const baseSpeed = (isTurbo ? (Math.random() * 6 + 3) : (Math.random() * 3 + 1)) * speedMult;
                
                this.vx = Math.cos(angle) * baseSpeed + (handVel.x * 0.4);
                this.vy = Math.sin(angle) * baseSpeed + (handVel.y * 0.4);
                
                this.gravity = 0.1; this.friction = 0.96; this.life = 1.0;
                this.decay = Math.random() * 0.01 + 0.005; 
                
                let sizeMult = 1.0;
                if (appSettings.photoSize === 1) sizeMult = 0.4;
                else if (appSettings.photoSize === 2) sizeMult = 0.7;
                else if (appSettings.photoSize === 3) sizeMult = 1.0;
                else if (appSettings.photoSize === 4) sizeMult = 1.6;
                else if (appSettings.photoSize === 5) sizeMult = 2.5;

                const aspect = this.img.width / this.img.height;
                const baseSizeRef = isTurbo ? 60 : 40; 
                const finalBaseSize = baseSizeRef * sizeMult;

                this.w = finalBaseSize * (Math.random() * 0.4 + 0.8);
                this.h = this.w / aspect;
                this.rot = Math.random() * 360;
                this.vRot = (Math.random() - 0.5) * 5; 
            } else {
                // æ™®é€šç²’å­
                const baseSpeed = isTurbo ? (Math.random() * 10 + 3) : (Math.random() * 5 + 1);
                this.vx = Math.cos(angle) * baseSpeed + (handVel.x * 0.3);
                this.vy = Math.sin(angle) * baseSpeed + (handVel.y * 0.3);
                this.gravity = 0.2; this.friction = 0.94; this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.01;
                
                const theme = colors[currentColorIdx];
                this.hue = theme.hue + (Math.random() * 30 - 15);
                this.sat = theme.sat;
                this.light = theme.light + Math.random() * 20;
                this.size = (Math.random() * 2.5 + 1) * (isTurbo ? 1.8 : 1.0);
            }
        }

        update() {
            this.vx *= this.friction; this.vy *= this.friction;
            this.vy += this.gravity; this.x += this.vx; this.y += this.vy;
            this.life -= this.decay;
            if (this.isPhoto) this.rot += this.vRot;
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            if (this.type === 'bg') {
                ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.life})`;
                if (this.style === 'star') {
                    ctx.translate(this.x, this.y); ctx.rotate(this.rot * Math.PI / 180); this.rot += 2; 
                    this.drawStar(ctx, 0, 0, 4, this.size * 2, this.size * 0.8);
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                }
            } else if (this.isPhoto) {
                ctx.translate(this.x, this.y); ctx.rotate(this.rot * Math.PI / 180);
                ctx.fillStyle = "#fff";
                const padding = Math.max(2, this.w * 0.05);
                ctx.fillRect(-this.w/2 - padding, -this.h/2 - padding, this.w + padding*2, this.h + padding*2);
                ctx.drawImage(this.img, -this.w/2, -this.h/2, this.w, this.h);
            } else {
                ctx.fillStyle = `hsl(${this.hue}, ${this.sat}%, ${this.light}%)`;
                ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = this.size > 2 ? 25 : 10;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }

        drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3; let x = cx, y = cy; let step = Math.PI / spikes;
            ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
                x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill();
        }
    }

    let bgParticles = [];
    let fgParticles = [];

    // --- æ‰‹éƒ¨ç±»ä¸æ£€æµ‹é€»è¾‘ ---
    class HandInstance {
        constructor() {
            this.pos = { x: -100, y: -100 }; this.lastPos = { x: -100, y: -100 };
            this.velocity = { x: 0, y: 0 };
            this.stabilizer = new Stabilizer(0.05, 0.8);
            this.angleStabilizer = new ValueStabilizer(0.12);
            this.stickAngle = 0;
            this.gesture = { isDetected: false, isPinching: false, isTurbo: false, isPalmOpen: false };
            this.lastSeen = 0;
        }

        update(landmarks, now) {
            this.lastSeen = now; this.gesture.isDetected = true;
            const p9 = landmarks[9], p0 = landmarks[0];
            const rawX = (1 - (p9.x * 0.75 + p0.x * 0.25)) * width;
            const rawY = (p9.y * 0.75 + p0.y * 0.25) * height;

            const smoothed = this.stabilizer.update(rawX, rawY);
            this.pos.x = smoothed.x; this.pos.y = smoothed.y;
            this.velocity.x = this.pos.x - this.lastPos.x; this.velocity.y = this.pos.y - this.lastPos.y;
            this.lastPos.x = this.pos.x; this.lastPos.y = this.pos.y;

            let targetTilt = Math.max(-35, Math.min(35, -this.velocity.x * 2.0));
            this.stickAngle = this.angleStabilizer.update(targetTilt);
            this.detectGestures(landmarks);
        }

        detectGestures(landmarks) {
            const indexTip = landmarks[8], thumbTip = landmarks[4];
            const tipsY = [landmarks[8].y, landmarks[12].y, landmarks[16].y, landmarks[20].y];
            const pipsY = [landmarks[6].y, landmarks[10].y, landmarks[14].y, landmarks[18].y];

            const pinchDist = Math.hypot((indexTip.x - thumbTip.x), (indexTip.y - thumbTip.y));
            this.gesture.isPinching = pinchDist < 0.08; 
            const isOpen = [tipsY[0]<pipsY[0], tipsY[1]<pipsY[1], tipsY[2]<pipsY[2], tipsY[3]<pipsY[3]];
            this.gesture.isTurbo = isOpen[0] && isOpen[1] && !isOpen[2] && !isOpen[3];
            this.gesture.isPalmOpen = isOpen[0] && isOpen[1] && isOpen[2] && isOpen[3];
        }
    }

    const handInstances = new Map();
    handInstances.set('Left', new HandInstance());
    handInstances.set('Right', new HandInstance());
    
    let globalGestureState = { lastColorChangeTime: 0 };
    const badges = {
        pinch: document.getElementById('badge-pinch'),
        peace: document.getElementById('badge-peace'),
        palm: document.getElementById('badge-palm')
    };

    resetBgGenerator(); // å¯åŠ¨èƒŒæ™¯ç²’å­

    // --- ç»“æœå¤„ç†ä¸å…¨å±€çŠ¶æ€æ›´æ–° ---
    function onResults(results) {
        const now = Date.now();
        if (results.multiHandLandmarks) {
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                let label = results.multiHandedness && results.multiHandedness[i] ? results.multiHandedness[i].label : 'Right';
                if (handInstances.has(label)) handInstances.get(label).update(results.multiHandLandmarks[i], now);
            }
        }
        
        // æ›´æ–° UI çŠ¶æ€
        let anyPinch = false, anyTurbo = false, anyPalm = false;
        for (let hand of handInstances.values()) {
            if (now - hand.lastSeen < 200) {
                if (hand.gesture.isPinching) anyPinch = true;
                if (hand.gesture.isTurbo) anyTurbo = true;
                if (hand.gesture.isPalmOpen) anyPalm = true;
            }
        }

        if (anyPalm && (now - globalGestureState.lastColorChangeTime > 1200)) {
            globalGestureState.lastColorChangeTime = now;
            currentColorIdx = (currentColorIdx + 1) % colors.length;
            const flash = document.createElement('div');
            flash.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;background:hsl(${colors[currentColorIdx].hue},50%,50%);opacity:0.2;pointer-events:none;z-index:999;transition:0.3s`;
            document.body.appendChild(flash);
            setTimeout(() => { flash.style.opacity = 0; setTimeout(()=>flash.remove(),300); }, 50);
        }

        if(anyPinch) badges.pinch.classList.add('active'); else badges.pinch.classList.remove('active');
        if(anyTurbo) badges.peace.classList.add('active'); else badges.peace.classList.remove('active');
        if(anyPalm) badges.palm.classList.add('active'); else badges.palm.classList.remove('active');
    }

    // --- æ¸²æŸ“å¾ªç¯ ---
    function loop() {
        requestAnimationFrame(loop);
        bgCtx.fillStyle = 'rgba(5, 5, 8, 0.25)';
        bgCtx.fillRect(0, 0, width, height);
        fgCtx.clearRect(0, 0, width, height);

        // èƒŒæ™¯ç²’å­
        for (let i = bgParticles.length - 1; i >= 0; i--) {
            let p = bgParticles[i]; p.update(); p.draw(bgCtx);
            if (p.life <= 0) bgParticles.splice(i, 1);
        }

        const now = Date.now();
        // æ‰‹éƒ¨ä¸ç«èŠ±
        for (let hand of handInstances.values()) {
            if (now - hand.lastSeen > 200) continue;

            // ç»˜åˆ¶æ‰‹æŸ„
            fgCtx.save();
            fgCtx.translate(hand.pos.x, hand.pos.y);
            fgCtx.rotate(hand.stickAngle * Math.PI / 180);
            fgCtx.strokeStyle = "#e0e0e0"; fgCtx.lineCap = "round"; fgCtx.lineWidth = 12; 
            fgCtx.beginPath(); fgCtx.moveTo(0, 0); fgCtx.lineTo(0, 180); fgCtx.stroke();
            fgCtx.strokeStyle = "#a0a0a0"; fgCtx.lineWidth = 4;
            fgCtx.beginPath(); fgCtx.moveTo(0, 20); fgCtx.lineTo(0, 170); fgCtx.stroke();
            fgCtx.fillStyle = "#ffd700"; fgCtx.fillRect(-7, 50, 14, 4); fgCtx.fillRect(-7, 80, 14, 4);
            const shouldEmit = hand.gesture.isPinching || hand.gesture.isTurbo;
            fgCtx.fillStyle = shouldEmit ? "#fff" : "#666";
            fgCtx.fillRect(-8, -15, 16, 45); 
            if (shouldEmit) {
                fgCtx.shadowBlur = hand.gesture.isTurbo ? 60 : 35; fgCtx.shadowColor = "#ffeb3b";
                fgCtx.fillStyle = "#fff"; fgCtx.beginPath(); fgCtx.arc(0, 0, hand.gesture.isTurbo ? 16 : 10, 0, Math.PI*2); fgCtx.fill();
            }
            fgCtx.restore();

            // å‘å°„ç²’å­
            if (shouldEmit) {
                const isPhotoMode = appSettings.usePhotoSparks && userPhotos.length > 0;
                let count = 0;
                if (isPhotoMode) {
                    const density = appSettings.photoDensity;
                    let spawnChance = density * 0.03; 
                    if (hand.gesture.isTurbo) spawnChance *= 2.0;
                    if (Math.random() < spawnChance) count = 1;
                } else {
                    count = hand.gesture.isTurbo ? 12 : 6;
                }

                for(let i=0; i<count; i++) {
                    fgParticles.push(new Particle(hand.pos.x, hand.pos.y, 'fg', hand.velocity, hand.gesture.isTurbo));
                }
            }
        }

        // å‰æ™¯ç²’å­
        for (let i = fgParticles.length - 1; i >= 0; i--) {
            let p = fgParticles[i]; p.update(); p.draw(fgCtx);
            if (p.life <= 0) fgParticles.splice(i, 1);
        }
    }
    // æ³¨æ„ï¼šä¸å†è‡ªåŠ¨è°ƒç”¨ loop()ï¼Œæ”¹ç”± startApp() è§¦å‘
</script>
</body>
</html>